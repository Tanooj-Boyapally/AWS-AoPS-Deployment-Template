name: Setup Terraform and Deploy EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Also allows manual trigger

jobs:
  setup:
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install Terraform
        run: |
          if command -v terraform &> /dev/null; then
            echo "Terraform is already installed"
            /usr/local/bin/terraform version || terraform version
          else
            echo "Installing Terraform..."
            TERRAFORM_VERSION="1.9.8"
            cd /tmp
            wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
            unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
            sudo mv terraform /usr/local/bin/
            sudo chmod +x /usr/local/bin/terraform
            rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
            echo "Terraform installed successfully"
          fi
          /usr/local/bin/terraform version

  # eks_setup:
  #   runs-on: self-hosted
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Verify Terraform is Available
  #       run: |
  #         which terraform
  #         /usr/local/bin/terraform version

  #     - name: Terraform Init
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform init

  #     - name: Terraform Plan
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform plan

  #     - name: Terraform Apply
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform apply -auto-approve
        
  #     - name: Configure kubectl
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name devops-cluster
          
  #         # Verify kubectl connection
  #         kubectl get nodes
          
  #         # Display cluster info
  #         kubectl cluster-info


  # ebs_setup:
  #   runs-on: self-hosted
  #   needs: setup
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Verify Terraform is Available
  #       run: |
  #         which terraform
  #         /usr/local/bin/terraform version

  #     - name: Terraform Init
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform init

  #     - name: Terraform Plan
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform plan

  #     - name: Terraform Apply
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform apply -auto-approve

  k8s_namespace_setup:
    runs-on: self-hosted
    needs: setup
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure kubectl for EKS
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Update kubeconfig for the EKS cluster
          aws eks --region us-east-1 update-kubeconfig --name devops-cluster
          echo "Kubeconfig updated successfully"

      - name: Verify kubectl connection
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Verify kubectl can connect to the cluster
          kubectl get nodes
          echo "Successfully connected to EKS cluster"

      - name: Create namespace
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Create namespace if it doesn't exist
          if kubectl get namespace aws-eoc &> /dev/null; then
            echo "Namespace 'aws-eoc' already exists"
          else
            kubectl create namespace aws-eoc
            echo "Namespace 'aws-eoc' created successfully"
          fi

      - name: Verify namespace
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          kubectl get namespace aws-eoc
          echo "Namespace verification complete"


  deploy_storageclass:
      runs-on: self-hosted
      needs: k8s_namespace_setup
      environment: production
      steps:
        - name: Checkout repository
          uses: actions/checkout@v3

        - name: Configure kubectl for EKS
          env:
            AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
          run: |
            # Update kubeconfig for the EKS cluster
            aws eks --region us-east-1 update-kubeconfig --name devops-cluster
            echo "Kubeconfig updated successfully"

        - name: Deploy StorageClass
          env:
            AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
          run: |
            echo "Applying StorageClass configuration..."
            kubectl apply -f aws-deployments/storageclass/storageclass.yaml
            echo "StorageClass applied successfully"

        - name: Verify StorageClass
          env:
            AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
          run: |
            echo "Verifying StorageClass..."
            kubectl get storageclass
            echo "StorageClass verification complete"
  

  deploy_pv_pvc:
    runs-on: self-hosted
    needs: deploy_storageclass
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure kubectl for EKS
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Update kubeconfig for the EKS cluster
          aws eks --region us-east-1 update-kubeconfig --name devops-cluster
          echo "Kubeconfig updated successfully"

      - name: Get EBS Volume ID and Update PV
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          # Fetch the volume ID from AWS
          VOLUME_ID=$(aws ec2 describe-volumes \
            --filters "Name=tag:Name,Values=mongodb-data-1" \
            --query "Volumes[0].VolumeId" \
            --output text)
          
          echo "Retrieved Volume ID: $VOLUME_ID"
          
          # Replace the placeholder with actual volume ID
          sed -i "s|volumeHandle: %ebs_volume%|volumeHandle: $VOLUME_ID|g" aws-deployments/statefulset/pv-pvc.yaml
          
          echo "Updated pv-pvc.yaml with Volume ID: $VOLUME_ID"
          
          # Display the updated section for verification
          echo "Updated PV configuration:"
          grep -A 2 "volumeHandle:" aws-deployments/statefulset/pv-pvc.yaml

      - name: Deploy PV and PVC
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Applying PV and PVC configuration..."
          kubectl apply -f aws-deployments/statefulset/pv-pvc.yaml
          echo "PV and PVC applied successfully"

      - name: Verify PV and PVC
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Verifying PersistentVolume..."
          kubectl get pv mongodb-pv
          
          echo "Verifying PersistentVolumeClaim..."
          kubectl get pvc mongodb-pvc -n aws-eoc
          
          echo "PV and PVC verification complete"