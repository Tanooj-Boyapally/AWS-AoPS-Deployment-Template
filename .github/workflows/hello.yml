name: Setup Terraform and Deploy EKS

on:
  # push:
  #   branches:
  #     - main
  workflow_dispatch:  # Also allows manual trigger

jobs:
  # setup:
  #   runs-on: self-hosted
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Install Terraform
  #       run: |
  #         if command -v terraform &> /dev/null; then
  #           echo "Terraform is already installed"
  #           /usr/local/bin/terraform version || terraform version
  #         else
  #           echo "Installing Terraform..."
  #           TERRAFORM_VERSION="1.9.8"
  #           cd /tmp
  #           wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  #           unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  #           sudo mv terraform /usr/local/bin/
  #           sudo chmod +x /usr/local/bin/terraform
  #           rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
  #           echo "Terraform installed successfully"
  #         fi
  #         /usr/local/bin/terraform version


  # ==========================================
  # STAGE 1: Create S3 Backend Infrastructure
  # ==========================================
  # s3_state_backend:
  #   runs-on: self-hosted
  #   environment: production
  #   outputs:
  #     state_bucket: ${{ steps.bucket_info.outputs.bucket_name }}
  #     dynamodb_table: ${{ steps.bucket_info.outputs.table_name }}
    
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Verify Terraform is Available
  #       run: |
  #         which terraform
  #         /usr/local/bin/terraform version

  #     - name: Terraform Init (S3 Backend)
  #       working-directory: ./aws-s3-bucket-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "ðŸ”§ Initializing Terraform for S3 state backend..."
  #         /usr/local/bin/terraform init

  #     - name: Terraform Plan (S3 Backend)
  #       working-directory: ./aws-s3-bucket-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "ðŸ“‹ Planning S3 backend infrastructure..."
  #         /usr/local/bin/terraform plan

  #     - name: Terraform Apply (S3 Backend)
  #       working-directory: ./aws-s3-bucket-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "ðŸš€ Creating S3 backend infrastructure..."
  #         /usr/local/bin/terraform apply -auto-approve

  #     - name: Get S3 Backend Info
  #       id: bucket_info
  #       working-directory: ./aws-s3-bucket-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "ðŸ“Š Retrieving backend configuration..."
  #         BUCKET_NAME=$(/usr/local/bin/terraform output -raw state_bucket_id)
  #         TABLE_NAME=$(/usr/local/bin/terraform output -raw dynamodb_table_name)
  #         echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
  #         echo "table_name=$TABLE_NAME" >> $GITHUB_OUTPUT
  #         echo "âœ… S3 Bucket: $BUCKET_NAME"
  #         echo "âœ… DynamoDB Table: $TABLE_NAME"

  #     - name: Display Backend Configuration
  #       working-directory: ./aws-s3-bucket-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "================================================"
  #         echo "âœ… S3 Backend Created Successfully!"
  #         echo "================================================"
  #         /usr/local/bin/terraform output backend_config



  # ebs_setup:
  #   runs-on: self-hosted
  #   # needs: setup
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Verify Terraform is Available
  #       run: |
  #         which terraform
  #         /usr/local/bin/terraform version

  #     - name: Configure Terraform Backend
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         cat > backend.tf << EOF
  #         terraform {
  #           backend "s3" {
  #             bucket  = "devops-terraform-state-backup"
  #             key     = "ebs-setup/terraform.tfstate"
  #             region  = "${{ secrets.AWS_REGION }}"
  #             encrypt = true
  #           }
  #         }
  #         EOF

  #     - name: Terraform Init
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform init

  #     - name: Terraform Plan
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform plan -lock=false

  #     - name: Terraform Apply
  #       working-directory: ./aws-ebs-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform apply -auto-approve -lock=false

  ebs_destroy:
    runs-on: self-hosted
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
  
      - name: Verify Terraform is Available
        run: |
          which terraform
          /usr/local/bin/terraform version
  
      - name: Configure Terraform Backend
        working-directory: ./aws-ebs-setup
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket  = "devops-terraform-state-backup"
              key     = "ebs-setup/terraform.tfstate"
              region  = "${{ secrets.AWS_REGION }}"
              encrypt = true
            }
          }
          EOF
  
      - name: Terraform Init
        working-directory: ./aws-ebs-setup
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: /usr/local/bin/terraform init
  
      - name: Terraform Plan (Destroy)
        working-directory: ./aws-ebs-setup
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: /usr/local/bin/terraform plan -destroy -lock=false
  
      - name: Terraform Destroy
        working-directory: ./aws-ebs-setup
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: /usr/local/bin/terraform destroy -auto-approve -lock=false



  # eks_setup:
  #   runs-on: self-hosted
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Verify Terraform is Available
  #       run: |
  #         which terraform
  #         /usr/local/bin/terraform version

  #     - name: Terraform Init
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform init

  #     - name: Terraform Plan
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform plan

  #     - name: Terraform Apply
  #       working-directory: ./aws-eks-setup
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: /usr/local/bin/terraform apply -auto-approve
        
  #     - name: Configure kubectl
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name devops-cluster
          
  #         # Verify kubectl connection
  #         kubectl get nodes
          
  #         # Display cluster info
  #         kubectl cluster-info




  # k8s_namespace_setup:
  #   runs-on: self-hosted
  #   needs: setup
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Configure kubectl for EKS
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #         echo "Kubeconfig updated successfully"

  #     - name: Verify kubectl connection
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Verify kubectl can connect to the cluster
  #         kubectl get nodes
  #         echo "Successfully connected to EKS cluster"

  #     - name: Create namespace
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Create namespace if it doesn't exist
  #         if kubectl get namespace aws-eoc &> /dev/null; then
  #           echo "Namespace 'aws-eoc' already exists"
  #         else
  #           kubectl create namespace aws-eoc
  #           echo "Namespace 'aws-eoc' created successfully"
  #         fi

  #     - name: Verify namespace
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         kubectl get namespace aws-eoc
  #         echo "Namespace verification complete"


  # deploy_storageclass:
  #     runs-on: self-hosted
  #     needs: k8s_namespace_setup
  #     environment: production
  #     steps:
  #       - name: Checkout repository
  #         uses: actions/checkout@v3

  #       - name: Configure kubectl for EKS
  #         env:
  #           AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #           AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #           AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #         run: |
  #           # Update kubeconfig for the EKS cluster
  #           aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #           echo "Kubeconfig updated successfully"

  #       - name: Deploy StorageClass
  #         env:
  #           AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #           AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #           AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #         run: |
  #           echo "Applying StorageClass configuration..."
  #           kubectl apply -f aws-deployments/storageclass/storageclass.yaml
  #           echo "StorageClass applied successfully"

  #       - name: Verify StorageClass
  #         env:
  #           AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #           AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #           AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #         run: |
  #           echo "Verifying StorageClass..."
  #           kubectl get storageclass
  #           echo "StorageClass verification complete"
  

  # deploy_pv_pvc:
  #   runs-on: self-hosted
  #   # needs: deploy_storageclass
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Configure kubectl for EKS
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #         echo "Kubeconfig updated successfully"

  #     - name: Get EBS Volume ID and Update PV
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Fetch the volume ID from AWS
  #         VOLUME_ID=$(aws ec2 describe-volumes \
  #           --filters "Name=tag:Name,Values=mongodb-data-1" \
  #           --query "Volumes[0].VolumeId" \
  #           --output text)
          
  #         echo "Retrieved Volume ID: $VOLUME_ID"
          
  #         # Replace the placeholder with actual volume ID
  #         sed -i "s|volumeHandle: %ebs_volume%|volumeHandle: $VOLUME_ID|g" aws-deployments/statefulset/pv-pvc.yaml
          
  #         echo "Updated pv-pvc.yaml with Volume ID: $VOLUME_ID"
          
  #         # Display the updated section for verification
  #         echo "Updated PV configuration:"
  #         grep -A 2 "volumeHandle:" aws-deployments/statefulset/pv-pvc.yaml

  #     - name: Deploy PV and PVC
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Applying PV and PVC configuration..."
  #         kubectl apply -f aws-deployments/statefulset/pv-pvc.yaml
  #         echo "PV and PVC applied successfully"

  #     - name: Verify PV and PVC
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Verifying PersistentVolume..."
  #         kubectl get pv mongodb-pv
          
  #         echo "Verifying PersistentVolumeClaim..."
  #         kubectl get pvc mongodb-pvc -n aws-eoc
          
  #         echo "PV and PVC verification complete"


  # deploy_statefulset:
  #   runs-on: self-hosted
  #   # needs: deploy_pv_pvc
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Configure kubectl for EKS
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #         echo "Kubeconfig updated successfully"

  #     - name: Deploy StatefulSet
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Applying StatefulSet configuration..."
  #         kubectl apply -f aws-deployments/statefulset/statefulset.yaml
  #         echo "StatefulSet applied successfully"

  #     - name: Verify StatefulSet
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Verifying StatefulSet..."
  #         kubectl get statefulset -n aws-eoc
          
  #         echo "Verifying Pods..."
  #         kubectl get pods -n aws-eoc
          
  #         echo "StatefulSet verification complete"

  # deploy_configmaps:
  #   runs-on: self-hosted
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Configure kubectl for EKS
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #         kubectl config set-context --current --namespace=aws-eoc
  #         echo "Kubeconfig updated successfully"

  #     - name: Deploy ConfigMaps
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Applying all ConfigMaps..."
  #         kubectl apply -f aws-deployments/configmap/
  #         echo "All ConfigMaps applied successfully"

  #     - name: Verify ConfigMaps
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Verifying ConfigMaps..."
  #         kubectl get configmap -n aws-eoc
          
  #         echo "Listing all ConfigMaps in detail..."
  #         kubectl get configmap -n aws-eoc -o wide
          
  #         echo "ConfigMap verification complete"

  # deploy_applications:
  #   runs-on: self-hosted
  #   # needs: deploy_configmaps
  #   environment: production
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Configure kubectl for EKS
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         # Update kubeconfig for the EKS cluster
  #         aws eks --region us-east-1 update-kubeconfig --name devops-cluster
  #         kubectl config set-context --current --namespace=aws-eoc
  #         echo "Kubeconfig updated successfully"

  #     - name: Deploy Applications and Services
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Applying all Deployments and Services..."
  #         kubectl apply -f aws-deployments/deploy/
  #         echo "All Deployments and Services applied successfully"

  #     - name: Verify Deployments and Services
  #       env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  #       run: |
  #         echo "Verifying Deployments..."
  #         kubectl get deployments -n aws-eoc
          
  #         echo "Verifying Services..."
  #         kubectl get services -n aws-eoc
          
  #         echo "Verifying Pods..."
  #         kubectl get pods -n aws-eoc -o wide
          
  #         echo "Application deployment verification complete"
